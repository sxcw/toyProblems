var addEven = function(arr){
	return arr.filter(function(element){
		if (element % 2 === 0){
			return element;
		}
	}).reduce(function(num1,num2){
		return num1+num2;
	})
}

addEven(arr);

var addEven2 = function (arr){
	var results = [];
	var total = 0; 
	for (var i =0; i<arr.length; i++){
		if (arr[i] %2 === 0) {
			results.push(arr[i]);
		}		
	}
	for (var i = 0; i <results.length; i++){
		total += results[i];
	}
	return total;
}

// Write a function answer_logger that takes a function as input, runs it, and console logs the return value from that function.
// We can test answer_logger using the following code, we should not need to change it at all.
// answer_logger(function(){
//   return "I should be console logged";
// });

var answer_logger = function(fn){
	console.log(fn())
}

var each = function(collection,callback){
	if (Array.isArray(collection)){
		for (var i = 0; i < collection.length; i++){
			callback(collection[i]);
		}
	} else {
		for (var key in collection) {
			callback(collection[key]);
		}
	}
};

var map = function(collection,callback){
	var results = [];
	each(collection, function(element){
		results.push(callback(element));
	})
	return results;
}

var filter = function(collection, test){
	var results = []; 
	each (collection, function(element){
		if(test(element)){
			results.push(element);
		}
	})
	return results; 
}

filter(["A","B",5], function(element){
	if(typeof element === "string") {
		return element;
	}
})
var reduce = function(collection,callback, startValue){
	var index = 0;
	if(startValue === undefined) {
		startValue  = collection[i];
		index = 1;
	}
}

var reduce = function(collection,accumulator,startValue){
	each (collection,function(value){
		if (startValue === undefined) {
			startValue = value; 
		} else {
			startValue = accumulator(startValue, value);
		}
	})
	return startValue; 
}

reduce([1,2,3,4],function(x,y){
	return x * y;
})



function isPalindrome (str) {
 	var checker = true;
	for (var i = 0; i < str.length; i++ ) {
		if(str[i] !== str [str.length-1-i]) {
			return false;
		}
	}
	return checker;
}

isPalindrome("kayak");
isPalindrome("racr");


function charSum (str) {
	var newStr = Number(str);
	console.log(newStr);
	var total = 0;
	for (var i = 0; i < newStr.length; i++){
		if(newStr[i]> 0){
			total += newStr[i];
		}
	}
	return total;

}

function charSum (str) {
	var total = 0;
	for (var i = 0; i < str.length; i++){
		if(Number(str[i])> 0){
			total += Number(str[i]);
		}
	}
	return total;
}

charSum("123"); 
charSum("cool2"); 

var people = ["Monica", "Erica", "Maclean", "Rita", "Tina", "Sandra", "Mary", "Jessica"];

var checkName = function(arr){
	return filter(arr,function(element){
		if(element.length> 6){
			return element;
		}
	})
}
checkName(people);

var checkName = function(arr){
	return arr.filter(function(element){
		if (element.length>6){
		 	return element;
		}
	})
}


var myArray = [1111,2222,33333,444,55,6];

var oddSum = function (arr){
	return filter(arr,function(element){
		if (element % 2 ===1){
			return element;
		}
	}).reduce(function(x,y){
	 	return x+y;
	})
}

oddSum(myArray)



//     Map Exercise
//     ============
//     Apply map to the players array and return an array of two-element arrays.  The two-element arrays should be composed of each player's name and their player efficiency rating.


map(players,function(player){
	return [player.name, player.playerEfficiencyRating];
})

//     Filter Exercise
//     ===============
//     Apply filter on the players array to return an array of player objects who average at least 35 minutes per game.


var goodPlayers = filter(players,function(player){
	if(player.minutesPerGame > 35){
		return player;
	}
})

//     Reduce Exercises
//     ================
//     1.  Apply reduce on the players array in order to return the sum of their true shooting percentages.  Then average those shooting percentages.  Finally, convert the numberical average of the form .673 into a string of the form "67.3%".  Finally, wrap all of this in a re-usable function that takes an array of players as a parameter.

//     2.  Create a function called "getLowestEWI".  It should take an array of player objects as a parameter.  Use reduce on the players array to find the player with the lowest estimated win average.  Then return the player's name from the function

var reduce = function(collection,accumulator, startValue){
	each(collection,function(value){
		if(startValue === undefined){
			startValue = value; 
		} else {
			startValue = accumulator (startValue, value);
		}
	})
	return startValue; 
}

reduce([1,2,3,4], function(x,y){
	return x+y; 
})


var reduce = function(collection,accumulator, startValue){
	each(collection,function(value){
		if(startValue === undefined){
			startValue = value; 
		} else {
			startValue = accumulator (startValue, value);
		}
	})
	return startValue; 
}
function getAv(arr){
	var playersSP = [];
	players.forEach(function(player){
		playersSP.push(player.trueShootingPercentage);
	})

	var sum = reduce(playersSP,function(num1, num2){
		return num1 + num2;
	})

	return ((sum/players.length)*100) + "%";

};
getAv(players);


// problem !!!
function getAv(arr){
	var sum = 0;
	reduce(arr,function(player1,player2){
		sum = player1.trueShootingPercentage + player2.trueShootingPercentage
		return;
	})
	console.log(sum);
	return ((sum/players.length)*100) + "%";
}

getAv(players);


players.reduce(function(acc, cur) {
	acc += cur.trueShootingPercentage
}, 0)




//     2.  Create a function called "getLowestEWI".  It should take an array of player objects as a parameter.  Use reduce on the players array to find the player with the lowest estimated win average.  Then return the player's name from the function




function getLowestEWI(arr){
	var estimatedWin = [];
	var lowest = map(arr,function(player){
		return player.estimatedWinAverage;
	}).reduce(function(val1, val2){
		if(val1 > val2){
			return val2
		} else {
			return val1;
		}
	});	
	for(var i = 0; i < arr.length; i++){
		if(arr[i].estimatedWinAverage === lowest){
			return arr[i].name;
		}
	}
}

getLowestEWI(players);



function getLowestEWI(arr){
	return reduce(arr,function(player1,player2){
		if(player1.estimatedWinAverage < player2.estimatedWinAverage){
			return player1;
		} else {
			return player2;
		}
	})["name"];
}


getLowestEWI(players);



var each = function(collection,callback){
	if (Array.isArray(collection)){
		for (var i = 0; i < collection.length; i++){
			callback(collection[i]);
		}
	} else {
		for (var key in collection) {
		 	callback(collection[key]);
		}
	}
}

var map = function(collection,callback){
	var results= [];
	each (collection, function(element){
		results.push(callback(element)); 
	})	
	return results; 
}

map ([3,4,5], function(element){
	return element + 2;
})

var filter = function(collection, callback){
	var results= [];
	each(collection, function(element){
		if(callback(element)){
			results.push(element);
		}
	})

	return results;
}

filter({name:"Katy", age:2, gender: "female"}, function(element){
	if (typeof element === "number"){
		return element;
	}
})

var reduce = function(collection, accumulator, startValue) {
	each(collection, function(value){
		if(startValue === undefined){
			startValue = value;
		} else {
			startValue = accumulator(startValue, value)
		}
	})
}

reduce([1,2,3,4,5], function(num1,num2){
	return num1 +num2;
})









function SecondGreatLow(arr) { 
	if (arr.length === 2){
		if(arr[0] > arr[1]) {
			return arr[0] + " " + arr[1];
		} else {
			return arr[1] + " " + arr[0];
		}
	} else {
		var greatest = Math.max.apply(Math, arr);
		var lowest = Math.min.apply(Math, arr);
		for (var i = 0; i<arr.length; i++) {
			if (arr[i] === greatest){
				arr.splice(arr.indexOf(i),1);
			}
			//arr.splice(arr.indexOf(greatest),1);
			//arr.splice(arr.indexOf(lowest),1);
			console.log(arr);
		}		
		for (var i = 0; i<arr.length; i++) {
			
			if(arr[i] === lowest){
				arr.splice(arr.indexOf(i),1);
			}
			//arr.splice(arr.indexOf(greatest),1);
			//arr.splice(arr.indexOf(lowest),1);
			console.log(arr);
		}	
		if (arr.length === 1){
			return arr.toString();
		} else {
			var secondGreatest = Math.max.apply(Math, arr);
			var secondLowest = Math.min.apply(Math, arr);
			return secondLowest + " " + secondGreatest;

		}
	}         
}

SecondGreatLow( [7, 7, 12, 98, 106]);

function reduce (collection, accumulator,startValue) {
	each(collection, function(value){
		if (startValue === undefined){
			startValue = value;
		} else {
			startValue = accumulator (startValue, value);
		}
	})
	return startValue;
}

function contains (collection, value) {
	var isFound = false; 
	reduce(collection, function(isFound, value){
		if (collection.indexOf(value) >-1){
			isFound = true;
			return isFound; 
		}
	})
	return isFound; 
}

//
// -----***********----------***********-----
//
//
// -----***********----------***********-----
//
//
// -----***********----------***********-----
//


var each = function(collection,callback){
	if(Array.isArray(collection)) {
		for(var i=0; i< collection.length; i++){
			callback(collection[i]);
		}
	} else {
		for (var key in collection) {
			callback(collection[key]);
		}
	}
}

var map = function (collection, callback) {
	var results= [];
	each (collection, function (element){
		results.push(callback(element));
	})
	return results; 
}

var filter = function (collection, predicate) {
	var results = []; 
	each (collection, function(element){
		if(predicate(element)){
			results.push (element);
		}
	})
	return results;
}

var reduce = function (collection, accumulator, startValue) {
	each (collection, function(current){
		if (startValue === undefined) {
			startValue = current; 
		} else {
			startValue= accumulator(startValue, current);
		}
	})
	return startValue; 
}

var contains = function (collection, target){
	return reduce(collection, function(isFound, current){
		if (current === target) {
			return true;
		} else {
			return isFound;
		}
	},false)
}

contains([1,2,3],13)


//
// -----***********----------***********-----
//
//
// -----***********----------***********-----
//
//
// -----***********----------***********-----
//

var players = [{ 
    "name": "Stephen Curry",
    "team": "OKC",
    "gamesPlayed":   40,
    "minutesPerGame": 34.3,
    "trueShootingPercentage": .679,
    "assistRatio": 19.9,
    "turnoverRatio": 10.7,
    "usageRate": 31.4,
    "offsensiveReboundRate": 2.5,
    "defensiveReboundRate":  13.5,
    "reboundRate": 8.3,
    "playerEfficiencyRating": 32.26,
    "valueAdded": 429.6,
    "estimatedWinAverage": 14.3 
},
{ 
    "name": "Russell Westbrook",
    "team": "OKC",
    "gamesPlayed":   43,
    "minutesPerGame": 33.9,
    "trueShootingPercentage": .554,
    "assistRatio": 27.1,
    "turnoverRatio": 11.8,
    "usageRate": 34.2,
    "offsensiveReboundRate": 5.7,
    "defensiveReboundRate":  16.7,
    "reboundRate": 11.5,
    "playerEfficiencyRating": 29.30,
    "valueAdded": 398.2,
    "estimatedWinAverage": 13.3 
},
{ 
    "name": "Kevin Durant",
    "team": "OKC",
    "gamesPlayed": 36,
    "minutesPerGame": 35.6,
    "trueShootingPercentage": .638,
    "assistRatio": 15.6,
    "turnoverRatio": 10.5,
    "usageRate": 28.0,
    "offsensiveReboundRate": 1.4,
    "defensiveReboundRate":  21.8,
    "reboundRate": 12.1,
    "playerEfficiencyRating": 28.35,
    "valueAdded": 341.5,
    "estimatedWinAverage": 11.4
},
{ 
    "name": "Lebron James",
    "team": "CLE",
    "gamesPlayed":  39,
    "minutesPerGame": 35.7,
    "trueShootingPercentage": .572,
    "assistRatio": 19.2,
    "turnoverRatio": 10.7,
    "usageRate": 31.5,
    "offsensiveReboundRate": 3.8,
    "defensiveReboundRate":  18.9,
    "reboundRate": 11.4,
    "playerEfficiencyRating": 26.51,
    "valueAdded": 332.4,
    "estimatedWinAverage": 11.1
},
{ 
    "name": "Kawhi Leonard",
    "team": "SA",
    "gamesPlayed":   40,
    "minutesPerGame": 33.2,
    "trueShootingPercentage": .615,
    "assistRatio": 12.7,
    "turnoverRatio": 6.9,
    "usageRate": 22.9,
    "offsensiveReboundRate": 4.7,
    "defensiveReboundRate":  18.6,
    "reboundRate": 12.0,
    "playerEfficiencyRating": 25.73,
    "valueAdded": 301.4,
    "estimatedWinAverage": 10.0
},
{
   "name": "Anthony Davis",
    "team": "NO",
    "gamesPlayed":   36,
    "minutesPerGame": 35.7,
    "trueShootingPercentage": .557,
    "assistRatio": 6.9,
    "turnoverRatio": 8.7,
    "usageRate": 26.1,
    "offsensiveReboundRate": 26.1,
    "defensiveReboundRate":  6.2,
    "reboundRate": 26.4,
    "playerEfficiencyRating": 24.74,
    "valueAdded": 254.0,
    "estimatedWinAverage": 8.5
},
{ 
    "name": "Chris Paul",
    "team": "LAC",
    "gamesPlayed":  36,
    "minutesPerGame": 32.4,
    "trueShootingPercentage": .557,
    "assistRatio": 33.4,
    "turnoverRatio": 9.6,
    "usageRate": 27.4,
    "offsensiveReboundRate": 2.0,
    "defensiveReboundRate":  10.8,
    "reboundRate": 6.4,
    "playerEfficiencyRating": 24.41,
    "valueAdded": 233.6,
    "estimatedWinAverage": 7.8
},
{ 
    "name": "DeMarcus Cousins",
    "team": "SAC",
    "gamesPlayed":   33,
    "minutesPerGame": 33.4,
    "trueShootingPercentage": .541,
    "assistRatio":  8.9,
    "turnoverRatio": 11.2,
    "usageRate": 32.8,
    "offsensiveReboundRate": 8.2,
    "defensiveReboundRate":  28.0,
    "reboundRate": 18.2,
    "playerEfficiencyRating": 24.15,
    "valueAdded": 222.7,
    "estimatedWinAverage": 7.4 
},
{
    "name": "James Harden",
    "team": "HOU",
    "gamesPlayed":   44,
    "minutesPerGame": 37.5,
    "trueShootingPercentage": .580,
    "assistRatio": 19.5,
    "turnoverRatio": 13.2,
    "usageRate": 32.3,
    "offsensiveReboundRate": 2.4,
    "defensiveReboundRate":  15.5,
    "reboundRate": 9.0,
    "playerEfficiencyRating": 24.06,
    "valueAdded": 334.0,
    "estimatedWinAverage": 11.1
},
{ 
    "name": "Paul Millsap",
    "team": "ATL",
    "gamesPlayed":  43,
    "minutesPerGame": 32.8,
    "trueShootingPercentage": .585,
    "assistRatio": 16.2,
    "turnoverRatio": 10.5,
    "usageRate": 23.2,
    "offsensiveReboundRate": 8.6,
    "defensiveReboundRate": 20.9,
    "reboundRate": 14.8,
    "playerEfficiencyRating": 23.73,
    "valueAdded": 257.3,
    "estimatedWinAverage": 8.6
},
];



//
// -----***********----------***********-----
//
//
// -----***********----------***********-----
//
//
// -----***********----------***********-----
//

function isPalingram (str){
	var strObj = {};
	var oddCount = [];
	for(var i = 0; i <str.length; i++){
		if (strObj[str[i]] === undefined){
			strObj[str[i]] = 1;
		} else {
			strObj[str[i]]++;
		}		
	}
	for (var key in strObj){
		if (strObj[key] %2 !== 0) {
			oddCount.push (strObj[key]);
		}
	}
	if (oddCount.length > 1) {
		return false;
	}
	return true;
}

isPalingram("aabbst");

// MAP
// ===
//     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
// Map, operates on an array, takes a callback, returns an array.  What you return becomes the value of the element at that position on the new array.
//     Map Exercise
//     ============
//     Apply map to the players array and return an array of two-element arrays.  The two-element arrays should be composed of each player's name and their player efficiency rating.

map(players,function(player){
	return [player.name, player.playerEfficiencyRating];
})

players.map(function(player){
	return [player.name, player.playerEfficiencyRating];
})

// FILTER
// ======
//     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
// Filter operates on an array.  It takes a callback (sometimes called a predicate) that returns true or false.  It returns an array composed of each element for which the callback returns true.
// Apply filter on the players array to return an array of player objects who average at least 35 minutes per game.

filter(players, function(player){
	if(player.minutesPerGame > 35) {
		return player
	}
})

players.filter(function(player){
	if(player.minutesPerGame > 35) {
		return player
	}
})




// REDUCE
// ======
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce
// Reduce operates on an array.  It takes a callback (sometimes called an accumulator) that builds up a value.  You can also think of the function as a whole "reducing" the array to a value.
//     Reduce Exercises
//     ================
//     1.  Apply reduce on the players array in order to return the sum of their true shooting percentages.  Then average those shooting percentages.  Finally, convert the numberical average of the form .673 into a string of the form "67.3%".  Finally, wrap all of this in a re-usable function that takes an array of players as a parameter.

//     2.  Create a function called "getLowestEWI".  It should take an array of player objects as a parameter.  Use reduce on the players array to find the player with the lowest estimated win average.  Then return the player's name from the function

var reduce = function (collection, accumulator, startValue) {
	each (collection, function(current){
		if (startValue === undefined) {
			startValue = current; 
		} else {
			startValue= accumulator(startValue, current);
		}
	})
	return startValue; 
}

function getAverage(arr) {
	var total = reduce(players,function(sum,player){
		return sum+= player.trueShootingPercentage;
	},0);
	return total/players.length *100 + "%"
}

function getAverage(arr) {

	var total = arr.reduce(function(sum,player){
		return sum += player.trueShootingPercentage;
	},0);
	return total/players.length *100 + "%"
}
getAverage(players);


//------------------------

function getLowestEWI(arr){
	return reduce(players,function(player1,player2){
		if (player1.estimatedWinAverage > player2.estimatedWinAverage){
			return player2;
		} else {
			return player1;
		}
	})["name"];
}

getLowestEWI(players);



